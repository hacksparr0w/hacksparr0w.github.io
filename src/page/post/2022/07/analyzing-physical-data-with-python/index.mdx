import { Figure } from "../../../../../component";
import { BlogPostParent } from "../../../../../partial";
import m87blackHoleImage from "./m87-black-hole.jpg";

export const parent = BlogPostParent;
export const metadata = {
  title: "Analyzing Physical Data with Python",
  subtitle: `
    Exploring the most useful concepts, techniques, and packages for physical
    data analysis with the Python programming language
  `,
  publishedOn: "July 18, 2022"
};

One of the most time-consuming exercises I got to do throughout my
undergraduate physics program was taking laboratory measurements of various
physical phenomena and analyzing the measured datapoints to prove or
disprove certain mathematical model describing the measured phenomenon. The
university courses I undertook covered the required theory behind all carried
experiments in great detail, and reproducing these experiments was not a
problem. However, courses usually focus very little on the actual data
analysis, and, as such, students tend to resort to using inefficient data
processing methods or spend much more time researching and tinkering with
various data analysis tools instead of focusing on the problem at hand.

This blog post presents basic building blocks for writing your own data
analysis scripts in the Python programming language. It contains a colorful
palette of ready-made code snippets with relevant examples of their
application in physics. We'll cover all the necessary steps of a typical
analysis procedure, from loading your data into Python's virtual memory,
through performing statistical regressions and numeric calculations, to
visualizing your results and outputting them into $\LaTeX$ documents.

It will probably take you some time before you come up with your own ideal
data analysis workflow, but I believe that by sharing some of the things I
discovered through numerous trials and errors, I can save you some headaches
and perhaps even make your time analyzing physical data a bit more enjoyable.

Please note that this is not meant to be an introduction to Python
programming and I'll be assuming at least a little knowledge of Python's
syntax on your part. If this is your first encounter with Python, I'd highly
encourage you to read through the official [Python documentation][1]. If you
are new to Python, you may still be able to learn a great deal just by playing
with the material shown here. Python is an incredibly intuitive programming
language and is made to be easily readable even for an untrained eye. Simply
copy-paste the included examples into a Python REPL, modify them to your
curiosity's accords, and see how far you get.

## Why Python?

The main difference between Python and other popular solutions for data
analysis, like, let's say, [qtiplot][2], is that Python is a proper programming
language. It is a program for making programs. As such, it is much more
powerful in its capabilities but also has a much steeper learning curve.

Although Python was originally not designed with scientific applications in
mind, its user-friendly language design and high-level nature made it very
appealing for scientists and engineers who aren't necessarily fluent in
low-level computing details and just want to get stuff done and iterate
quickly. Over the years, Python has become extremely fashionable in the
scientific community, and its vibrant ecosystem of packages for number
crunching and data visualization makes it an excellent choice for data
analysis of any kind. To mention just one example out of many, the first-ever
picture of a black hole was
[computationally constructed using Python and Numpy][3].

<Figure
  image={m87blackHoleImage}
  caption={`
    The very first image of a supermassive black hole from the M87 galaxy. The
    image was computationally constructed using Python and various third-party
    scientific packages. Credits to the photo belong to the Event Horizon
    Telescope Collaboration.
  `}
/>

## Python development environments

Python code is just plain text, so you can use any text editor you like to
write Python programs. Text editors come with varying degrees of support for
programming languages. There are lightweight but still very powerful text
editors like [Sublime Text][4] that offer syntax-highlighting,
autocompletion, and some useful graphical features, but usually don't go
beyond that. Then there are so-called integrated development environments
(IDEs), which come with full support for your language of choice, providing
features like a built-in debugger, dependency management, test runner, and so on.
A very popular IDE for Python is [PyCharm][5]. My personal favorite is
[Visual Studio Code][6], which is a very customizable, language-agnostic IDE.

Another noteworthy development environment for Python is [Jupyter][7]. Jupyter
is a beast of its own and was purposely built for data visualization and
presentation. Jupyter comes with a web-based interface that runs your
Python code and outputs your results with pretty visuals and interactive
elements. It also lets you annotate your code and your plots with formatted
text and create beautiful documents. Jupyter notebooks are a perfect way to
bundle the results of your calculations in a nice interactive wrapping, but I
find them quite clumsy when it comes to actual coding and prototyping.

One last remark to be made when talking about Python environments: make sure
you are always using the latest stable version of Python 3, not Python 2.
Python 2 has been [deprecated since January 1, 2020][8], and things will not
work properly if you use it.

## Packages for scientific computing

 - numpy and pandas
 - uncertainties and pint
 - scipy
 - sympy
 - plotly and kaleido

## Loading data and performing basic math

Now that we've handled all the necessary formalities, let's start with some
actual physics. We'll start slow and simple to demonstrate some basics, and
we'll gradually move on to more complex exercises.

Let's start with geometry. Suppose we have a cuboid of unknown dimensions $a$,
$b$, and $c$. We would like to measure these dimensions and then calculate the
volume $V$ of this cuboid. The volume $V$ can be calculated as

$$
  V = a \cdot b \cdot c.
$$

Simple enough, right? The next step is to take some measurements with a
standard metric ruler.

The proper way to take measurements and evaluate uncertainties with a standard
metric ruler would be the [Type A evaluation of standard uncertainty][9].
According to this standard, we need to take a sample of $N$ independent
measurements. After that, we can estimate the true value of the measured
variable as the [sample mean][10] and the standard uncertainty as the
[standard deviation of the mean][11] (sometimes referred to as standard
error). Given $N$ observations $x_i$, the sample mean $\bar x$ can be
calculated as

$$
  \bar x = \frac\{1\}\{N\} \sum_\{i=1\}^N x_i.
$$

The standard deviation of the mean $s$ can be calculated as

$$
  s = \sqrt\{\frac\{1\}\{N \cdot (N - 1)\} \sum_\{i=1\}^N (x_i - \bar x)^2 \}.
$$

For our purposes, taking ten measurements should be good enough, so we'll set
$N = 10$. To get ourselves some data without having to venture out into the
real world, we'll simulate measurements of sides of our
cuboid as sampling a [normally distributed set of values][12]. We'll define
true values for the dimensions of our cuboid as $a^* = 1.6 \\, \mathrm\{cm\}$,
$b^* = 1.6 \\, \mathrm\{cm\}$, and $c^* = 1.1 \\, \mathrm\{cm\}$. These values
are the means of our normal distributions. The standard deviation for our
normal distributions will be $\sigma = 0.05 \\, \mathrm\{cm\}$, which is one
half of the smallest measurement unit of the standard metric ruler. To sample
our normal distributions with Python, we'll use the function
[`numpy.random.normal`][13]. Open up your Python REPL, import Numpy,
and try entering the following statement.

```python
>>> numpy.random.normal(1.6, 0.05, 10)
array([1.64468312, 1.67546263, 1.64805655, 1.55413015, 1.56795639,
       1.60147243, 1.59246804, 1.57452395, 1.51630531, 1.58456757])
```

This line of code produces an array of ten random values from a normally
distributed set with mean $\mu = 1.6$ and standard deviation $\sigma = 0.05$.
These values seem pretty good, but a standard metric ruler does only have a
precision of one millimeter, so we'll have to round our values with
the [`numpy.ndarray.round`][14] function.

```python
>>> numpy.random.normal(1.6, 0.05, 10).round(1)
array([1.5, 1.6, 1.5, 1.7, 1.5, 1.6, 1.6, 1.6, 1.6, 1.6])
```

This looks much better. We could just work with these values directly, but this
exercise should teach you how to load your data from disk into Python's
memory. When carrying out a physical experiment, you'd usually write down your
measurements into a notebook or use a laptop or a tablet and save the measured
values into a file on your hard drive.

```csv
a,b,c
1.6,1.6,1.2
1.7,1.6,1.1
1.6,1.6,1.1
1.6,1.6,1.1
1.7,1.6,1.1
1.6,1.6,1.1
1.6,1.6,1.1
1.5,1.7,1.1
1.6,1.6,1.0
1.7,1.6,1.1
```

[1]: https://docs.python.org/3/
[2]: https://www.qtiplot.com/
[3]: https://numpy.org/case-studies/blackhole-image/
[4]: https://www.sublimetext.com/
[5]: https://www.jetbrains.com/pycharm/
[6]: https://code.visualstudio.com/
[7]: https://jupyter.org/
[8]: https://github.com/python/devguide/pull/344
[9]: https://physics.nist.gov/cuu/Uncertainty/typea.html
[10]: https://en.wikipedia.org/wiki/Sample_mean_and_covariance
[11]: https://en.wikipedia.org/wiki/Standard_deviation#Standard_deviation_of_the_mean
[12]: https://en.wikipedia.org/wiki/Normal_distribution
[13]: https://numpy.org/doc/stable/reference/random/generated/numpy.random.normal.html
[14]: https://numpy.org/doc/stable/reference/generated/numpy.ndarray.round.html
